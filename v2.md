# Codux V2 Architecture

## Executive Summary

V2 is a complete rebuild of the Codux application focusing on cleaner architecture, better separation of concerns, and simpler state management. This document outlines the problems with V1 and the improved patterns for V2.

---

## V1 Problems & Technical Debt

### 1. Context Architecture Issues

**Problem**: Multiple context providers scattered at different levels
```typescript
// layout.tsx
<AppProvider>           // Mobile detection only

// page.tsx
<ProjectProvider>       // Panel state
  <PreviewProvider>     // Preview + fullscreen + code mode
    <HomeContent />
```

**Issues**:
- Providers at wrong levels (PreviewProvider should be in layout, not page)
- Fullscreen mode requires accessing PreviewContext from page level
- Provider hierarchy makes state sharing awkward
- No clear single source of truth

### 2. PreviewContext Overload

**Problem**: Single context handling too many responsibilities
```typescript
type PreviewContextType = {
  device: DeviceType;              // Viewport device type
  setDevice: (device: DeviceType) => void;
  customWidth: number | null;      // Custom width
  setCustomWidth: (width: number | null) => void;
  customHeight: number | null;     // Custom height
  setCustomHeight: (height: number | null) => void;
  dimensions: Dimensions;          // Actual rendered dimensions
  setDimensions: (dimensions: Dimensions) => void;
  showCode: boolean;               // Code viewer mode
  setShowCode: (show: boolean) => void;
  showFileTree: boolean;           // File tree visibility
  setShowFileTree: (show: boolean) => void;
  isFullscreen: boolean;           // Fullscreen mode
  setFullscreen: (fullscreen: boolean) => void;
};
```

**Issues**:
- Mixes viewport state, UI mode state, and layout state
- 7 state variables + 7 setters = 14 context values
- Difficult to understand what depends on what
- Poor separation of concerns

### 3. Panel Toggle Complexity

**Problem**: Over-engineered panel management
```typescript
const [showChat, setShowChat] = useState(true);
const [showIntegrations, setShowIntegrations] = useState(false);
const [previousPanel, setPreviousPanel] = useState<"chat" | "integrations" | null>(null);

const toggleChat = () => {
  setShowChat((prev) => {
    if (!prev) {
      if (showIntegrations) {
        setPreviousPanel("integrations");
        setShowIntegrations(false);
      }
      return true;
    } else {
      if (previousPanel === "integrations") {
        setShowIntegrations(true);
        setPreviousPanel(null);
      }
      return false;
    }
  });
};
```

**Issues**:
- Complex mutual exclusivity logic
- previousPanel tracking adds unnecessary state
- Logic could be much simpler
- Unclear intent

### 4. Mobile Detection Anti-Pattern

**Problem**: Global context for responsive breakpoint
```typescript
// app-context.tsx
const isMobile = useMobile(1280); // xl breakpoint
return (
  <AppContext.Provider value={{ isMobile }}>
```

**Issues**:
- Responsive design is a CSS concern, not React state
- Forces re-renders when window resizes
- Should use Tailwind's responsive classes instead
- Context pollution for purely presentational concern

### 5. Fullscreen Implementation Hack

**Problem**: Fullscreen requires complex conditional rendering at page level
```typescript
// page.tsx
const HomeContent = () => {
  const { isFullscreen } = usePreviewContext();
  return (
    <div>
      {!isFullscreen && <AppHeader />}  // Conditionally hide header
      <AppLayout />
    </div>
  );
};

// preview/panel.tsx
if (isFullscreen) {
  return (
    <div className="fixed inset-0 flex flex-col">  // Break out of layout
      <PreviewHeader />
      {showCode ? <CodePanel /> : <PreviewViewport />}
    </div>
  );
}
```

**Issues**:
- Fullscreen is layout concern, shouldn't be in preview context
- Breaks component encapsulation
- Multiple conditional rendering locations
- Hard to reason about layout flow

### 6. Layout File Confusion

**Problem**: Layout logic spread across 3 files
- `app/layout.tsx` - Root HTML, AppProvider
- `app/page.tsx` - ProjectProvider, PreviewProvider, conditional header
- `components/app-layout.tsx` - Panel layout, mobile sheets

**Issues**:
- Unclear responsibility boundaries
- Logic duplication between mobile/desktop
- Hard to find where layout decisions are made

### 7. Missing Viewport Controls

**Problem**: Width input was removed from viewport controls
```typescript
// What was there before:
<div className="flex items-center gap-0.5 text-xs text-gray-600 bg-accent rounded px-2 py-1">
  <span className="text-gray-400 pointer-events-none">W</span>
  <Input
    type="number"
    value={dimensions.width || ""}
    onChange={handleWidthChange}
    className="h-auto w-12 border-0 shadow-none bg-transparent p-0 text-center text-xs"
  />
</div>
```

**Issues**:
- No way to see current viewport dimensions
- No manual width/height input
- Viewport controls incomplete

---

## V2 Architecture Improvements

### 1. Simplified Context Hierarchy

**Proposal**: Single unified app context at root level
```typescript
// app/layout.tsx - Single provider
<AppProvider>
  {children}
</AppProvider>

// AppContext contains all app-level state:
type AppContextType = {
  // Layout state
  leftPanel: "chat" | null;
  rightPanel: "integrations" | null;
  setLeftPanel: (panel: "chat" | null) => void;
  setRightPanel: (panel: "integrations" | null) => void;

  // Preview state
  viewportMode: "desktop" | "tablet" | "mobile" | "custom";
  setViewportMode: (mode: ViewportMode) => void;
  customDimensions: { width: number; height: number } | null;
  setCustomDimensions: (dims: Dimensions | null) => void;

  // UI mode state
  previewMode: "preview" | "code";
  setPreviewMode: (mode: "preview" | "code") => void;
  fullscreen: boolean;
  setFullscreen: (fullscreen: boolean) => void;
  showFileTree: boolean;
  setShowFileTree: (show: boolean) => void;
};
```

**Benefits**:
- Single source of truth
- All state at correct level (layout)
- Clear state categories
- Easy to access from any component

### 2. Separation of Concerns

**Proposal**: Organize state by domain
```typescript
// Layout state - which panels are open
leftPanel: "chat" | null
rightPanel: "integrations" | null

// Preview state - viewport configuration
viewportMode: "desktop" | "tablet" | "mobile" | "custom"
customDimensions: { width, height } | null

// UI mode state - preview vs code, fullscreen
previewMode: "preview" | "code"
fullscreen: boolean
showFileTree: boolean
```

**Benefits**:
- Clear domain boundaries
- Easy to understand what affects what
- Better mental model
- Easier to extend

### 3. Simplified Panel Management

**Proposal**: Remove mutual exclusivity, support both panels open
```typescript
// Simple open/close
const openChat = () => setLeftPanel("chat");
const closeChat = () => setLeftPanel(null);
const toggleChat = () => setLeftPanel(prev => prev ? null : "chat");

const openIntegrations = () => setRightPanel("integrations");
const closeIntegrations = () => setRightPanel(null);
const toggleIntegrations = () => setRightPanel(prev => prev ? null : "integrations");
```

**Benefits**:
- No previousPanel tracking
- Simpler logic
- Both panels can be open simultaneously
- More flexible for future features

### 4. Responsive Without Context

**Proposal**: Use Tailwind responsive utilities, remove isMobile context
```typescript
// Instead of:
{!isMobile && <DesktopControls />}
{isMobile && <MobileControls />}

// Use:
<div className="hidden xl:block">
  <DesktopControls />
</div>
<div className="xl:hidden">
  <MobileControls />
</div>
```

**Benefits**:
- No unnecessary re-renders
- Standard CSS responsive patterns
- Easier to understand
- Better performance

### 5. Fullscreen as Layout Mode

**Proposal**: Handle fullscreen in layout, not component
```typescript
// app/page.tsx
export default function Home() {
  const { fullscreen } = useAppContext();

  return (
    <div className="h-full flex flex-col gap-2">
      {!fullscreen && <AppHeader />}
      <AppLayout />  {/* Layout handles fullscreen internally */}
    </div>
  );
}

// components/app-layout.tsx
export const AppLayout = () => {
  const { fullscreen, leftPanel, rightPanel } = useAppContext();

  if (fullscreen) {
    return <PreviewPanel />;  // Takes full space
  }

  return (
    <div className="flex flex-1 overflow-hidden min-h-0 gap-2">
      {leftPanel && <ChatPanel />}
      <PreviewPanel />
      {rightPanel && <IntegrationsPanel />}
    </div>
  );
};
```

**Benefits**:
- Layout concern stays in layout
- No fixed positioning hacks
- Cleaner component tree
- Easier to understand

### 6. Complete Viewport Controls

**Proposal**: Add width/height inputs back with responsive visibility
```typescript
export const ViewportControls = () => {
  const { viewportMode, customDimensions, dimensions } = useAppContext();

  return (
    <div className="flex items-center gap-2">
      {/* Device selector dropdown */}
      <DeviceDropdown />

      {/* Dimension inputs - only on xl+ screens */}
      <div className="hidden xl:flex items-center gap-2">
        <DimensionInput label="W" value={dimensions.width} />
        <DimensionInput label="H" value={dimensions.height} />
      </div>
    </div>
  );
};
```

**Benefits**:
- See current dimensions
- Manual input for custom sizes
- Responsive visibility
- Complete feature set

### 7. Clear File Organization

**Proposal**: Consolidate layout logic
```
app/
  layout.tsx       - Root HTML, AppProvider only
  page.tsx         - AppHeader + AppLayout (simple)

components/
  app-context.tsx  - All app state
  app-header.tsx   - Header component
  app-layout.tsx   - Main layout logic (panels, fullscreen)

  chat/
    panel.tsx      - Chat panel shell

  preview/
    panel.tsx      - Preview panel shell
    header.tsx     - Preview header
    viewport.tsx   - Preview viewport
    controls.tsx   - Viewport controls

  integrations/
    panel.tsx      - Integrations panel shell
```

**Benefits**:
- Clear responsibility for each file
- Easy to find where things are
- No logic duplication
- Better maintainability

---

## V2 Implementation Strategy

### Phase 1: Context Foundation
1. Create new `app-context.tsx` with unified AppContext
2. Update `app/layout.tsx` to use AppProvider only
3. Remove old context files (project-context, preview-context)

### Phase 2: Layout Simplification
1. Simplify `app/page.tsx` to minimal wrapper
2. Rebuild `app-layout.tsx` with clean panel logic
3. Implement fullscreen handling in layout

### Phase 3: Component Shells
1. Create empty panel components (no content)
2. Rebuild AppHeader with cleaner patterns
3. Test layout behaviors (panel toggling, fullscreen)

### Phase 4: Preview Features
1. Add viewport controls with dimension inputs
2. Implement device switching
3. Add resize handle
4. Implement code mode

### Phase 5: Panel Content
1. Add chat functionality back
2. Add integrations functionality back
3. Add code panel with file tree
4. Add viewport content

---

## Panel Architecture: Card vs Dialog

### Current Analysis

Looking at existing UI components:

**Card Component** (`ui/card.tsx`):
- Provides consistent wrapper styling
- `bg-card`, `rounded-xl`, `border`, `shadow-sm`, `py-6`
- Subcomponents: CardHeader, CardTitle, CardContent, CardFooter
- Static, always visible component

**Sheet Component** (`ui/sheet.tsx`):
- Built on Base UI Dialog primitive (`@base-ui-components/react/dialog`)
- Includes backdrop/overlay (`Dialog.Backdrop`)
- Uses `Dialog.Popup` for the panel content
- Animated slide-in/out transitions
- Portal-based rendering
- Currently used for mobile panels

### V2 Panel Strategy

**Desktop Panels (Chat & Integrations)**:
Use **Dialog.Popup without backdrop** for non-modal panel behavior:

```typescript
// Non-modal panel using Dialog without backdrop
<Dialog.Root open={leftPanel === "chat"}>
  <Dialog.Popup
    modal={false}  // Non-modal: no backdrop, doesn't trap focus
    className="bg-white rounded-md border shadow-sm"
  >
    <ChatPanel />
  </Dialog.Popup>
</Dialog.Root>
```

**Benefits**:
- Based on Dialog primitive (accessibility built-in)
- Non-modal behavior (no backdrop, no focus trap)
- Can click outside to interact with other panels
- Consistent with Sheet (same primitive)
- Better than plain divs (semantic, accessible)

**Mobile Panels**:
Continue using **Sheet** (Dialog with backdrop):
- Modal behavior appropriate for mobile
- Backdrop prevents interaction with content behind
- Slide-in animation
- Close button for dismissal

**Preview Panel**:
Use **Card** wrapper for consistent styling:
```typescript
<Card className="flex-1 flex flex-col min-h-0">
  <PreviewHeader />
  <PreviewContent />
  <PreviewFooter />
</Card>
```

### Implementation Pattern

```typescript
// Desktop: Non-modal dialogs without backdrop
<div className="hidden xl:flex flex-1 gap-2">
  {/* Left panel - Chat */}
  <Dialog.Root open={leftPanel === "chat"} onOpenChange={(open) => !open && closeChat()}>
    <Dialog.Popup modal={false} className="w-[30%]">
      <Card>
        <ChatPanel />
      </Card>
    </Dialog.Popup>
  </Dialog.Root>

  {/* Center - Preview */}
  <Card className="flex-1">
    <PreviewPanel />
  </Card>

  {/* Right panel - Integrations */}
  <Dialog.Root open={rightPanel === "integrations"} onOpenChange={(open) => !open && closeIntegrations()}>
    <Dialog.Popup modal={false} className="w-[30%]">
      <Card>
        <IntegrationsPanel />
      </Card>
    </Dialog.Popup>
  </Dialog.Root>
</div>

// Mobile: Sheets with backdrops
<div className="xl:hidden flex-1">
  <Card className="flex-1">
    <PreviewPanel />
  </Card>

  <Sheet open={leftPanel === "chat"} onOpenChange={(open) => !open && closeChat()}>
    <SheetContent side="left">
      <ChatPanel />
    </SheetContent>
  </Sheet>

  <Sheet open={rightPanel === "integrations"} onOpenChange={(open) => !open && closeIntegrations()}>
    <SheetContent side="right">
      <IntegrationsPanel />
    </SheetContent>
  </Sheet>
</div>
```

### Why This Approach?

1. **Semantic HTML**: Dialog primitives provide proper ARIA roles
2. **Accessibility**: Built-in keyboard navigation, focus management
3. **Consistency**: All panels use same Dialog primitive (Sheet = Dialog + Backdrop)
4. **Flexibility**: Non-modal on desktop, modal on mobile
5. **Transitions**: Dialog handles open/close animations
6. **Styling**: Card provides consistent visual wrapper
7. **Base UI Philosophy**: Use primitives for behavior, style with Tailwind

### Alternative: Pure Divs with Transitions

```typescript
// Simpler approach with width transitions
<div className="flex gap-2">
  <div className={cn(
    "flex-shrink-0 transition-all ease-in-out duration-300 overflow-hidden",
    leftPanel === "chat" ? "w-[30%]" : "w-0"
  )}>
    <Card className="min-w-max h-full">
      <ChatPanel />
    </Card>
  </div>

  <Card className="flex-1">
    <PreviewPanel />
  </Card>

  <div className={cn(
    "flex-shrink-0 transition-all ease-in-out duration-300 overflow-hidden",
    rightPanel === "integrations" ? "w-[30%]" : "w-0"
  )}>
    <Card className="min-w-max h-full">
      <IntegrationsPanel />
    </Card>
  </div>
</div>
```

**Pros**:
- Simpler implementation (no Dialog complexity)
- Smooth width transitions (current behavior)
- Easier to understand and maintain
- Cards always in DOM (faster transitions)
- No portal rendering overhead

**Cons**:
- Less semantic than Dialog
- Manual transition handling
- Panels always in DOM even when hidden

### Decision: Start Simple, Enhance Later

**V2 Phase 1**: Use **Pure Divs + Transitions** approach
- Simpler to implement and understand
- Maintains current smooth transition behavior
- Easier to debug and reason about
- All panels use Card for consistent styling

**Future Enhancement**: Consider Dialog.Popup later if needed
- If accessibility audit reveals issues
- If we need modal-like behaviors (focus trapping, ESC to close)
- If we want portal-based rendering for z-index management

**Mobile**: Continue using **Sheet** (Dialog with backdrop)
- Modal behavior is correct for mobile
- Already works well
- Accessibility built-in

---

## Key Principles for V2

1. **Single Source of Truth**: One context, clear ownership
2. **Separation of Concerns**: Layout, viewport, and UI mode are separate
3. **Simplicity First**: Remove unnecessary complexity
4. **Composition Over Configuration**: Build up from simple pieces
5. **Responsive by Design**: Use CSS, not React state
6. **Progressive Enhancement**: Start with structure, add features incrementally
7. **Base UI Primitives**: Use Dialog for panels, Card for styling

---

## Migration Notes

### Breaking Changes
- All old contexts (ProjectContext, PreviewContext) removed
- New AppContext with different API
- Layout structure changed
- Mobile detection removed (use Tailwind responsive)

### Upgrade Path
1. Components using old contexts must update to AppContext
2. Replace `isMobile` checks with Tailwind classes
3. Update fullscreen handling to use new layout
4. Viewport controls need new dimension input handlers

---

## Success Criteria

V2 is successful when:
- [ ] Single unified AppContext
- [ ] All layout logic in app-layout.tsx
- [ ] No provider nesting in page.tsx
- [ ] Fullscreen handled in layout
- [ ] Complete viewport controls with inputs
- [ ] Simpler panel toggle logic
- [ ] No mobile context (pure CSS responsive)
- [ ] Clear file responsibilities
- [ ] Easier to understand and maintain
